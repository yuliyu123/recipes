
1. 空类的大小为什么是1？
编译器禁止空类为0空类也进行了实例化，
每个实例在内存中都有一个独一无二的地址，
为了达到这个目的，编译器一般会给一个空类隐含的加一个字节，
这样就可以达到空类在实例化后得到了独一无二的地址的目的。

2. 构造函数和析构函数能否为虚函数？
构造函数不能，析构函数可以。
因为含有虚函数的class一定会有vtable,在构造的时候产生。如果构造函数是虚函数，那么就需要通过vtable 来调用，
可此时vtabl_(:з」∠)_e还没有产生，所以掉不到。

析构函数可以是虚函数，且常常如此

这个就好理解了，因为此时 vtable 已经初始化了；况且我们通常通过基类的指针来销毁对象，
如果析构函数不为虚的话，就不能正确识别对象类型，从而不能正确销毁对象。

3. int在内存中字节排布？ 小端序。
数据的高位字节存放在地址的高端,低位字节存放在地址低端
。高位对应高地址，低位对应低地址。
大端序相反。
https://www.cnblogs.com/graphics/archive/2011/04/22/2010662.html

4. 进程的内存结构：
栈、动态库装载区、堆、静态区（静态变量和全局变量，随程序销毁）、代码文本段、保留区。
进程线程的区别：
https://www.jianshu.com/p/9a3720912164

5. static关键字：
文件的全局可见，存储在静态区，对外部文件不可见。生存周期长，
https://blog.csdn.net/artechtor/article/details/2312766

6. 多进程同时监听一个端口：
Linux3.9以后的新特性。
Linux kernel 3.9带来了SO_REUSEPORT特性。
SO_REUSEPORT支持多个进程或者线程绑定到同一端口，提高服务器程序的性能，解决的问题：
允许多个套接字 bind()/listen() 同一个TCP/UDP端口
每一个线程拥有自己的服务器套接字
在服务器套接字上没有了锁的竞争
内核层面实现负载均衡
安全层面，监听同一个端口的套接字只能位于同一个用户下面
以前通过fork形式创建多个子进程，现在有了SO_REUSEPORT，可以不用通过fork的形式，
让多进程监听同一个端口，各个进程中accept socket fd不一样，有新连接建立时，
内核只会唤醒一个进程来accept，并且保证唤醒的均衡性。

https://www.nowcoder.com/questionTerminal/0767872fc4c64959b73cc360e573f784?toCommentId=180324

7. 进程间通信？
socket, 管道，消息队列，共享内存

8. hash冲突怎么解决？
   拉链和线性探查

9. coredum的产生及原理：
默认不开启，因为core的size为0。
设置开启：ulimit -c unlimited
查看：ulimit -c
在Linux上，我们可以使用kill向一个指定的进程发送信号或者使用gcore命令来使其主动出Core并退出。
当前进程触犯了某些OS层级的保护机制，使得OS向当前进程发送诸如SIGSEGV(即signal 11)之类的信号, 
例如访问空指针或数组越界出Core，实际上是触犯了OS的内存管理，访问了非当前进程的内存空间，
OS需要通过出Core来进行警示。

触发了系统的内存保护机制，向进程发出一个信号，杀死该进程产生core文件。
core文件保存着该进程终止时在系统中的堆栈、寄存器信息。
